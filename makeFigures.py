# -*- coding: utf-8 -*-
"""
Created on Thu Feb  6 09:46:15 2020

@author: Tiago
"""
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
import csv
from rdkit import Chem
from rdkit.Chem import Crippen
from rdkit.Chem import Descriptors as desc
from rdkit.Chem import QED
from utils import reading_csv,load_config,generate2file,smiles2mol
from tokens import tokens_table
from sascorer_calculator import SAscore
from prediction import Predictor
from keras.models import Sequential
from model import Model 

colors = ['#ff7f0e', '#1f77b4', '#d62728', '#2ca02c', '#9467bd']  # orange, blue, green, red, purple
           
def properties_violin(filepaths,labels,pred_type):
    
    properties = []
      
    for i,fname in enumerate(filepaths):
        with open(filepaths[i], 'r') as f:
            reader = csv.reader(f)
        
            it = iter(reader)
#            next(it, None)  # skip first item.    
            for row in it:
                    if pred_type == 'pIC50':
                        properties.append([labels[i],'IC50 for KOR',float(row[1])]) 
                    if i != 0:
                        properties.append([labels[i],'SA score',float(row[2])])
                        try:
                            mol = Chem.MolFromSmiles(row[0])
                            q = QED.qed(mol)
    #                        x, y = desc.MolWt(mol), Crippen.MolLogP(mol)
    #                        properties.append([labels[i],'Molecular weight',x])
    #                        properties.append([labels[i],'logP',y])
                            properties.append([labels[i],'QED',q])
                            
                        except: 
                            print("Non-Canonical SMILES: " + row[0])
                    else:
                        
                        try:
                            mole = smiles2mol(row[0])
                            prediction_sas = SAscore(mole)
                            properties.append([labels[i],'SA score',float(prediction_sas[0])])
                            mol = Chem.MolFromSmiles(row[0])
                            q = QED.qed(mol)
    #                        x, y = desc.MolWt(mol), Crippen.MolLogP(mol)
    #                        properties.append([labels[i],'Molecular weight',x])
    #                        properties.append([labels[i],'logP',y])
                            properties.append([labels[i],'QED',q])
                        except: 
                            print("Non-Canonical SMILES: " + row[0])
                    
    df = pd.DataFrame(properties, columns=['Sets', 'Property', 'Value'])
    return df

def properties_mw_logp(filepaths): 
    
    properties = []
      
    for i,fname in enumerate(filepaths):
        with open(filepaths[i], 'r') as f:
            reader = csv.reader(f)
        
            it = iter(reader)
            if not ("generated" in fname):
                for row in it:
                    try:
                        properties.append([float(row[2]),float(row[3]),i])
                    except:
                        print("")
            else:
                for row in it:
                    try:
                        mol = Chem.MolFromSmiles(row[0])
                        x, y = desc.MolWt(mol), Crippen.MolLogP(mol)
                        properties.append([x,y,i])
                    except: 
                        print("Non-Canonical SMILES: " + row[0])

    df = pd.DataFrame(properties[2000:2355], columns=['MW', 'logP', 'Label'])
    return df


def violin_plot(pred_identifier):
    """ 
    violin plot for the physicochemical properties comparison.
    A: molecules generated by pre-trained model v.s. Chembl set.
    """
    config_file = 'configReinforce.json' 
    configReinforce,exp_time=load_config(config_file)
    
    if pred_identifier == 'pIC50':
         # Load the predictor model
        predictor = Predictor(configReinforce,'kor')
    else:
        predictor = None
    
    biased_generator = Sequential()
    biased_generator = Model(configReinforce)
    unbiased_generator = Sequential()
    unbiased_generator = Model(configReinforce)
    biased_generator.model.load_weights(configReinforce.model_name_biased+".h5")
    unbiased_generator.model.load_weights(configReinforce.model_name_unbiased)

    # generate with unbiased
    generate2file(predictor,unbiased_generator,configReinforce,100,True)
    generate2file(predictor,biased_generator,configReinforce,100,False)
#     
    plt.figure(figsize=(7, 6))
    
    sns.set(rc={"axes.facecolor":"white",
            "axes.grid":False,
            'axes.labelsize':20,
            'figure.figsize':(20.0, 10.0),
            'xtick.labelsize':15,
            'ytick.labelsize':15})
    
#    sns.set(style="white", palette="colorblind", color_codes=True)
    df = properties_violin(['Generated/generated_prop_original.smi','Generated/generated_prop_biased.smi'], ['Original generator', 'Fine-tuned generator'],pred_identifier)
    sns.violinplot(x='Property', y='Value', hue='Sets', data=df, linewidth=1, split=True, bw=1, legend = False)
    sns.despine(left=True)
    plt.ylim([-3, 15])
#    viol_plot.ax.legend(loc=2)

def mw_logp_plot():  
    """
    Chemical space comparison based on logP ~ MW
    """
    fig = plt.figure(figsize=(12, 12))
    lab = ['Chembl Dataset', 'Fine-tuned dataset']
    ax1 = fig.add_subplot(221)
    df = properties_mw_logp(['data/tyk_clean.csv', 'data/generated.smi'])

    group0, group1 = df[df.Label == 0], df[df.Label== 1]
    ax1.scatter(group0.MW, group0.logP, s=10, marker='o', label=lab[0], c='', edgecolor=colors[1])
    ax1.scatter(group1.MW, group1.logP, s=10, marker='o', label=lab[1], c='', edgecolor=colors[3])
    ax1.set(ylabel='LogP', xlabel='Molecular Weight')
    ax1.legend(loc='lower right')

    
def performance_barplot():
    # Mean square error 
    objects = ('RNN', 'SVM', 'RF', 'KNN')
    y_pos = np.arange(len(objects))
    performance_mse = [0.0299,0.0531,0.0524,0.0566]
    
    plt.bar(y_pos, performance_mse, align='center', alpha=0.5, color=['blue' ,'yellow', 'green','red'],  edgecolor='black')
    plt.xticks(y_pos, objects)
    plt.ylabel('MSE')
    plt.title('QSAR models evaluation: Mean Squared Error')
    plt.show()
    

    y_pos = np.arange(len(objects))
    performance_r2 = [71.4,57.0,57.6,54.1]
    
    plt.bar(y_pos, performance_r2, align='center', alpha=0.5, color=['blue' ,'yellow', 'green','red'],  edgecolor='black')

    plt.xticks(y_pos, objects)
    plt.ylabel('R2 Score')
    plt.title('QSAR models evaluation: R-squared')
    plt.show()

def regression_plot(y_true,y_pred):
    fig, ax = plt.subplots()
    ax.scatter(y_true, y_pred)
    ax.plot([np.min(y_true), np.max(y_true)], [np.min(y_true), np.max(y_true)], 'k--', lw=4)
    ax.set_xlabel('True')
    ax.set_ylabel('Predicted')
    plt.show()
    
def main():
    """
    Main routine
    """
    predictor = 'pIC50' # pIC50 or sas          
#    y_true = [1, 2, 3,4,5,2,2,1,3]
#    y_pred = [1.1, 1.6, 3, 4.1, 4.5, 1.8, 2,1.6,3.1]
#    regression_plot(y_true,y_pred)
    performance_barplot()
    violin_plot(predictor)
#    mw_logp_plot()

if __name__ == '__main__':
    main()